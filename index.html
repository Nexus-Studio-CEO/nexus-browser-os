<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NEXUS Browser OS</title>
  <meta name="description" content="Complete operating system running 100% in your browser">
  <link rel="manifest" href="manifest.json">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
      background: #0a0a0f;
      color: #e8e8f0;
    }

    /* BOOT SCREEN */
    #boot-screen {
      position: fixed;
      inset: 0;
      background: #0a0a0f;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      transition: opacity 0.5s ease;
    }

    #boot-screen.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .boot-logo {
      font-size: 48px;
      font-weight: 700;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 30px;
    }

    #power-button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 15px 40px;
      border-radius: 50px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
    }

    #power-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 15px 40px rgba(102, 126, 234, 0.5);
    }

    #power-button:active {
      transform: translateY(0);
    }

    #boot-logs {
      margin-top: 30px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      color: #70d6a3;
      max-width: 600px;
      text-align: left;
      display: none;
    }

    #boot-logs.visible {
      display: block;
    }

    .boot-log {
      padding: 4px 0;
      opacity: 0;
      animation: fadeInLog 0.3s ease forwards;
    }

    @keyframes fadeInLog {
      to { opacity: 1; }
    }

    /* DESKTOP */
    #desktop {
      position: fixed;
      inset: 0;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      display: none;
    }

    #desktop.active {
      display: block;
    }

    /* Thèmes dynamiques */
    #desktop.theme-dark {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    }

    #desktop.theme-light {
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
    }

    #desktop.theme-purple {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    #desktop-wallpaper {
      position: absolute;
      inset: 0;
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1920 1080"><defs><linearGradient id="grad" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:%23667eea;stop-opacity:0.2"/><stop offset="100%" style="stop-color:%23764ba2;stop-opacity:0.2"/></linearGradient></defs><rect width="1920" height="1080" fill="url(%23grad)"/></svg>');
      background-size: cover;
      background-position: center;
      pointer-events: none;
    }

    #windows-container {
      position: absolute;
      inset: 0 0 60px 0;
    }

    /* WINDOW */
    .window {
      position: absolute;
      background: rgba(26, 26, 36, 0.95);
      backdrop-filter: blur(20px);
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-width: 400px;
      min-height: 300px;
    }

    .window-titlebar {
      background: rgba(102, 126, 234, 0.1);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding: 12px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: move;
      user-select: none;
    }

    .window-title {
      font-size: 14px;
      font-weight: 600;
      color: #e8e8f0;
    }

    .window-controls {
      display: flex;
      gap: 8px;
    }

    .window-btn {
      width: 32px;
      height: 32px;
      border-radius: 6px;
      border: none;
      background: rgba(255, 255, 255, 0.05);
      color: #e8e8f0;
      font-size: 18px;
      cursor: pointer;
      transition: background 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }

    .window-btn:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .window-btn.close:hover {
      background: #ff5555;
    }

    .window-content {
      flex: 1;
      overflow: hidden;
      position: relative;
    }

    /* TASKBAR */
    #taskbar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 60px;
      background: rgba(26, 26, 36, 0.95);
      backdrop-filter: blur(20px);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      padding: 0 20px;
      gap: 12px;
    }

    .taskbar-start {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .taskbar-start:hover {
      transform: scale(1.05);
    }

    .taskbar-apps {
      display: flex;
      gap: 8px;
      flex: 1;
    }

    .taskbar-app {
      background: rgba(255, 255, 255, 0.05);
      border: none;
      padding: 8px 16px;
      border-radius: 8px;
      color: #e8e8f0;
      font-size: 13px;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .taskbar-app:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .taskbar-app.active {
      background: rgba(102, 126, 234, 0.3);
    }

    .taskbar-system {
      display: flex;
      align-items: center;
      gap: 16px;
      font-size: 13px;
      color: #9090a8;
    }

    #taskbar-username {
      font-weight: 500;
      color: #667eea;
    }

    /* START MENU */
    #start-menu {
      position: absolute;
      bottom: 70px;
      left: 20px;
      width: 400px;
      max-height: 600px;
      background: rgba(26, 26, 36, 0.98);
      backdrop-filter: blur(20px);
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.1);
      padding: 20px;
      display: none;
      overflow-y: auto;
    }

    #start-menu.visible {
      display: block;
      animation: slideUp 0.2s ease;
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .start-section {
      margin-bottom: 24px;
    }

    .start-section-title {
      font-size: 12px;
      font-weight: 600;
      color: #9090a8;
      text-transform: uppercase;
      margin-bottom: 12px;
      letter-spacing: 0.5px;
    }

    .start-apps {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .start-app {
      background: rgba(255, 255, 255, 0.05);
      border: none;
      padding: 16px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: left;
      color: #e8e8f0;
    }

    .start-app:hover {
      background: rgba(102, 126, 234, 0.2);
      transform: translateY(-2px);
    }

    .start-app-name {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .start-app-desc {
      font-size: 11px;
      color: #9090a8;
    }
  </style>
</head>
<body>
  <!-- BOOT SCREEN -->
  <div id="boot-screen">
    <div class="boot-logo">NEXUS OS</div>
    <div style="font-size: 12px; color: #9090a8; margin-bottom: 30px;">Powered by Nexus Studio</div>
    <button id="power-button">Power On</button>
    <div id="boot-logs"></div>
  </div>

  <!-- DESKTOP -->
  <div id="desktop">
    <div id="desktop-wallpaper"></div>
    <div id="windows-container"></div>

    <!-- TASKBAR -->
    <div id="taskbar">
      <button class="taskbar-start" id="start-button">Start</button>
      <div class="taskbar-apps" id="taskbar-apps"></div>
      <div class="taskbar-system">
        <span id="taskbar-username"></span>
        <span id="system-time">00:00</span>
      </div>
    </div>

    <!-- START MENU -->
    <div id="start-menu">
      <div class="start-section">
        <div class="start-section-title">Applications</div>
        <div class="start-apps" id="start-apps-list"></div>
      </div>
      <div class="start-section">
        <div class="start-section-title">System</div>
        <div class="start-apps">
          <button class="start-app" data-app="task-manager">
            <div class="start-app-name">Task Manager</div>
            <div class="start-app-desc">Monitor processes</div>
          </button>
          <button class="start-app" data-app="settings">
            <div class="start-app-name">Settings</div>
            <div class="start-app-desc">Configure system</div>
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- LDSS SDK -->
  <script src="https://ldss-e9kz.onrender.com/ldss-client.js"></script>

  <!-- SYSTEM MODULES -->
  <script type="module">
    // ═══════════════════════════════════════════════
    // CONSOLE INTERCEPTOR (for logs.html)
    // ═══════════════════════════════════════════════

    (function() {
      const originalLog = console.log;
      const originalError = console.error;
      const originalWarn = console.warn;

      function sendToParent(level, args) {
        if (window.parent !== window) {
          try {
            window.parent.postMessage({
              type: 'console',
              level,
              message: args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' '),
              data: args.length === 1 && typeof args[0] === 'object' ? args[0] : null
            }, '*');
          } catch (e) {
            // Ignore if can't send
          }
        }
      }

      console.log = function(...args) {
        originalLog.apply(console, args);
        sendToParent('INFO', args);
      };

      console.error = function(...args) {
        originalError.apply(console, args);
        sendToParent('ERROR', args);
      };

      console.warn = function(...args) {
        originalWarn.apply(console, args);
        sendToParent('WARN', args);
      };

      // Catch unhandled errors
      window.addEventListener('error', (e) => {
        console.error('[UNHANDLED ERROR]', e.message, e.filename, e.lineno, e.colno);
        sendToParent('ERROR', [e.message, { filename: e.filename, line: e.lineno, col: e.colno }]);
      });

      window.addEventListener('unhandledrejection', (e) => {
        console.error('[UNHANDLED PROMISE REJECTION]', e.reason);
        sendToParent('ERROR', ['Promise rejection:', e.reason]);
      });
    })();

    console.log('[SYSTEM] NEXUS OS loading...');
    console.log('[SYSTEM] Console interceptor active');

    // ═══════════════════════════════════════════════
    // CPU MANAGER (Compute Engine)
    // ═══════════════════════════════════════════════
    class CPUManager {
      constructor(gateway) {
        this.gateway = gateway;
        this.cores = [];
        this.numCores = 4;
        this.queue = [];
        this.nextTaskId = 1;
        this.pendingTasks = new Map();

        this.initWorkers();
      }

      initWorkers() {
        this.gateway.logger.info('CPU', { message: 'Initializing CPU cores...', numCores: this.numCores });

        for (let i = 0; i < this.numCores; i++) {
          const worker = this.createWorker(i);
          this.cores.push({
            id: i,
            worker,
            busy: false,
            tasksCompleted: 0
          });
        }

        this.gateway.logger.info('CPU', { message: 'CPU cores ready', numCores: this.numCores });
      }

      createWorker(coreId) {
        const workerCode = `
          self.onmessage = function(e) {
            const { taskId, task, params } = e.data;
            
            try {
              let result;
              
              switch(task) {
                case 'fibonacci':
                  result = fibonacci(params.n);
                  break;
                case 'factorial':
                  result = factorial(params.n);
                  break;
                case 'isPrime':
                  result = isPrime(params.n);
                  break;
                case 'hash':
                  result = simpleHash(params.data);
                  break;
                case 'sort':
                  result = params.array.slice().sort((a, b) => a - b);
                  break;
                case 'search':
                  result = params.array.filter(item => 
                    JSON.stringify(item).toLowerCase().includes(params.query.toLowerCase())
                  );
                  break;
                case 'compute':
                  // Generic computation
                  result = eval(params.expression);
                  break;
                default:
                  throw new Error('Unknown task: ' + task);
              }
              
              self.postMessage({ taskId, success: true, result });
            } catch (error) {
              self.postMessage({ taskId, success: false, error: error.message });
            }
          };
          
          function fibonacci(n) {
            if (n <= 1) return n;
            let a = 0, b = 1;
            for (let i = 2; i <= n; i++) {
              [a, b] = [b, a + b];
            }
            return b;
          }
          
          function factorial(n) {
            if (n <= 1) return 1;
            let result = 1;
            for (let i = 2; i <= n; i++) {
              result *= i;
            }
            return result;
          }
          
          function isPrime(n) {
            if (n <= 1) return false;
            if (n <= 3) return true;
            if (n % 2 === 0 || n % 3 === 0) return false;
            
            for (let i = 5; i * i <= n; i += 6) {
              if (n % i === 0 || n % (i + 2) === 0) return false;
            }
            return true;
          }
          
          function simpleHash(data) {
            let hash = 0;
            const str = String(data);
            for (let i = 0; i < str.length; i++) {
              const char = str.charCodeAt(i);
              hash = ((hash << 5) - hash) + char;
              hash = hash & hash;
            }
            return hash.toString(16);
          }
        `;

        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(blob);
        const worker = new Worker(workerUrl);

        worker.onmessage = (e) => {
          this.handleWorkerResponse(coreId, e.data);
        };

        worker.onerror = (error) => {
          this.gateway.logger.error('CPU', { coreId, error: error.message });
        };

        return worker;
      }

      async executeTask(task, params) {
        const taskId = this.nextTaskId++;

        this.gateway.logger.info('CPU', { 
          action: 'task_queued', 
          taskId, 
          task, 
          queueLength: this.queue.length 
        });

        return new Promise((resolve, reject) => {
          this.pendingTasks.set(taskId, { resolve, reject, task, params });
          this.queue.push({ taskId, task, params });
          this.processQueue();
        });
      }

      async executeBatch(tasks) {
        this.gateway.logger.info('CPU', { 
          action: 'batch_queued', 
          count: tasks.length 
        });

        const promises = tasks.map(({ task, params }) => 
          this.executeTask(task, params)
        );

        return Promise.all(promises);
      }

      processQueue() {
        if (this.queue.length === 0) return;

        const availableCore = this.cores.find(core => !core.busy);
        if (!availableCore) return;

        const { taskId, task, params } = this.queue.shift();

        availableCore.busy = true;
        availableCore.worker.postMessage({ taskId, task, params });

        this.gateway.logger.info('CPU', { 
          action: 'task_executing', 
          taskId, 
          coreId: availableCore.id 
        });

        // Continue processing queue
        if (this.queue.length > 0) {
          setTimeout(() => this.processQueue(), 0);
        }
      }

      handleWorkerResponse(coreId, data) {
        const core = this.cores[coreId];
        const { taskId, success, result, error } = data;

        core.busy = false;
        core.tasksCompleted++;

        const pendingTask = this.pendingTasks.get(taskId);
        if (!pendingTask) return;

        if (success) {
          this.gateway.logger.info('CPU', { 
            action: 'task_completed', 
            taskId, 
            coreId,
            tasksCompleted: core.tasksCompleted
          });
          pendingTask.resolve(result);
        } else {
          this.gateway.logger.error('CPU', { 
            action: 'task_failed', 
            taskId, 
            coreId, 
            error 
          });
          pendingTask.reject(new Error(error));
        }

        this.pendingTasks.delete(taskId);
        this.processQueue();
      }

      getStats() {
        return {
          cores: this.numCores,
          busyCores: this.cores.filter(c => c.busy).length,
          queueLength: this.queue.length,
          totalTasksCompleted: this.cores.reduce((sum, c) => sum + c.tasksCompleted, 0),
          coreStats: this.cores.map(c => ({
            id: c.id,
            busy: c.busy,
            tasksCompleted: c.tasksCompleted
          }))
        };
      }

      terminate() {
        this.cores.forEach(core => core.worker.terminate());
        this.gateway.logger.info('CPU', { message: 'All CPU cores terminated' });
      }
    }

    // ═══════════════════════════════════════════════
    // SYSTEM LOGGER
    // ═══════════════════════════════════════════════
    class SystemLogger {
      constructor() {
        this.logs = [];
        this.maxLogs = 1000;
      }

      log(level, category, data) {
        const entry = {
          timestamp: new Date().toISOString(),
          level,
          category,
          ...data
        };

        this.logs.push(entry);
        if (this.logs.length > this.maxLogs) {
          this.logs.shift();
        }

        const prefix = `[${level}] [${category}]`;
        console.log(prefix, data);
      }

      info(category, data) { this.log('INFO', category, data); }
      warn(category, data) { this.log('WARN', category, data); }
      error(category, data) { this.log('ERROR', category, data); }

      getStats() {
        return {
          total: this.logs.length,
          byLevel: {
            INFO: this.logs.filter(l => l.level === 'INFO').length,
            WARN: this.logs.filter(l => l.level === 'WARN').length,
            ERROR: this.logs.filter(l => l.level === 'ERROR').length
          }
        };
      }

      getLogs(limit = 100) {
        return this.logs.slice(-limit).reverse();
      }
    }

    // ═══════════════════════════════════════════════
    // WINDOW MANAGER
    // ═══════════════════════════════════════════════
    class WindowManager {
      constructor(gateway) {
        this.gateway = gateway;
        this.windows = new Map();
        this.zIndex = 100;
        this.dragState = null;
      }

      create(options) {
        const { title, width, height, pid } = options;

        const win = document.createElement('div');
        win.className = 'window';
        win.dataset.pid = pid;
        win.style.width = width + 'px';
        win.style.height = height + 'px';
        win.style.left = (window.innerWidth / 2 - width / 2) + 'px';
        win.style.top = (window.innerHeight / 2 - height / 2 - 30) + 'px';
        win.style.zIndex = this.zIndex++;

        win.innerHTML = `
          <div class="window-titlebar">
            <span class="window-title">${title}</span>
            <div class="window-controls">
              <button class="window-btn minimize">−</button>
              <button class="window-btn maximize">□</button>
              <button class="window-btn close">×</button>
            </div>
          </div>
          <div class="window-content"></div>
        `;

        const titlebar = win.querySelector('.window-titlebar');
        const closeBtn = win.querySelector('.close');
        const minimizeBtn = win.querySelector('.minimize');
        const maximizeBtn = win.querySelector('.maximize');

        // Close
        closeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.gateway.closeApp(pid);
        });

        // Minimize
        minimizeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.minimize(pid);
        });

        // Maximize
        maximizeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.maximize(pid);
        });

        // Drag
        titlebar.addEventListener('mousedown', (e) => {
          if (e.target.closest('.window-controls')) return;

          this.focus(pid);

          this.dragState = {
            pid,
            startX: e.clientX,
            startY: e.clientY,
            startLeft: win.offsetLeft,
            startTop: win.offsetTop
          };
        });

        // Focus on click
        win.addEventListener('mousedown', () => {
          this.focus(pid);
        });

        document.getElementById('windows-container').appendChild(win);

        this.windows.set(pid, {
          element: win,
          state: 'normal',
          originalBounds: null
        });

        return win;
      }

      setupDragListeners() {
        document.addEventListener('mousemove', (e) => {
          if (!this.dragState) return;

          const { pid, startX, startY, startLeft, startTop } = this.dragState;
          const win = this.windows.get(pid);
          if (!win) return;

          const deltaX = e.clientX - startX;
          const deltaY = e.clientY - startY;

          win.element.style.left = (startLeft + deltaX) + 'px';
          win.element.style.top = (startTop + deltaY) + 'px';
        });

        document.addEventListener('mouseup', () => {
          this.dragState = null;
        });
      }

      close(pid) {
        const win = this.windows.get(pid);
        if (!win) return;

        win.element.remove();
        this.windows.delete(pid);
      }

      minimize(pid) {
        const win = this.windows.get(pid);
        if (!win) return;

        win.element.style.display = 'none';
        win.state = 'minimized';

        this.gateway.updateTaskbar();
      }

      restore(pid) {
        const win = this.windows.get(pid);
        if (!win) return;

        win.element.style.display = 'flex';
        win.state = 'normal';
        this.focus(pid);

        this.gateway.updateTaskbar();
      }

      maximize(pid) {
        const win = this.windows.get(pid);
        if (!win) return;

        if (win.state === 'maximized') {
          const bounds = win.originalBounds;
          win.element.style.left = bounds.x + 'px';
          win.element.style.top = bounds.y + 'px';
          win.element.style.width = bounds.width + 'px';
          win.element.style.height = bounds.height + 'px';
          win.state = 'normal';
        } else {
          win.originalBounds = {
            x: win.element.offsetLeft,
            y: win.element.offsetTop,
            width: win.element.offsetWidth,
            height: win.element.offsetHeight
          };

          win.element.style.left = '0';
          win.element.style.top = '0';
          win.element.style.width = '100vw';
          win.element.style.height = 'calc(100vh - 60px)';
          win.state = 'maximized';
        }
      }

      focus(pid) {
        const win = this.windows.get(pid);
        if (!win) return;

        win.element.style.zIndex = this.zIndex++;
      }
    }

    // ═══════════════════════════════════════════════
    // STORAGE MANAGER (LDSS Integration)
    // ═══════════════════════════════════════════════
    class StorageManager {
      constructor(gateway) {
        this.gateway = gateway;
        this.db = null;
        this.connected = false;
        this.autoSaveInterval = null;

        // Configuration LDSS - REMPLACER PAR VOTRE TOKEN
        this.config = {
          token: 'demo_token', // ⚠️ REMPLACER PAR VOTRE TOKEN LDSS
          projectName: 'NexusOS',
          apiUrl: 'https://ldss-e9kz.onrender.com'
        };
      }

      async init() {
        try {
          this.gateway.logger.info('STORAGE', { message: 'Initializing LDSS...' });

          this.db = new LDSS(this.config);
          this.connected = true;

          this.gateway.logger.info('STORAGE', { message: 'LDSS connected successfully' });

          // Charger état sauvegardé
          await this.restoreSystemState();

          // Activer auto-save toutes les 30 secondes
          this.startAutoSave();

        } catch (error) {
          this.gateway.logger.error('STORAGE', { 
            message: 'LDSS initialization failed', 
            error: error.message 
          });
          this.connected = false;
        }
      }

      async set(key, value) {
        try {
          if (!this.connected || !this.db) {
            this.gateway.logger.warn('STORAGE', { 
              message: 'LDSS not connected, using fallback' 
            });
            // Fallback: localStorage
            localStorage.setItem(key, JSON.stringify(value));
            return;
          }

          await this.db.store('nexus_storage', { 
            key, 
            value,
            timestamp: Date.now()
          });

          this.gateway.logger.info('STORAGE', { action: 'set', key });
        } catch (error) {
          this.gateway.logger.error('STORAGE', { 
            action: 'set', 
            key, 
            error: error.message 
          });
          // Fallback
          localStorage.setItem(key, JSON.stringify(value));
        }
      }

      async get(key) {
        try {
          if (!this.connected || !this.db) {
            // Fallback: localStorage
            const item = localStorage.getItem(key);
            return item ? JSON.parse(item) : null;
          }

          const result = await this.db.get('nexus_storage', key);
          return result?.value;
        } catch (error) {
          this.gateway.logger.error('STORAGE', { 
            action: 'get', 
            key, 
            error: error.message 
          });
          // Fallback
          const item = localStorage.getItem(key);
          return item ? JSON.parse(item) : null;
        }
      }

      async saveSystemState() {
        try {
          const state = {
            apps: Array.from(this.gateway.apps.entries()).map(([pid, app]) => ({
              pid: app.pid,
              name: app.name,
              state: app.state,
              launchedAt: app.launchedAt
            })),
            windows: Array.from(this.gateway.windowManager.windows.entries()).map(([pid, win]) => ({
              pid,
              state: win.state,
              bounds: win.originalBounds
            })),
            timestamp: Date.now()
          };

          await this.set('system_state', state);

          this.gateway.logger.info('STORAGE', { 
            action: 'system_state_saved', 
            appsCount: state.apps.length 
          });
        } catch (error) {
          this.gateway.logger.error('STORAGE', { 
            action: 'save_system_state_failed', 
            error: error.message 
          });
        }
      }

      async restoreSystemState() {
        try {
          const state = await this.get('system_state');

          if (!state) {
            this.gateway.logger.info('STORAGE', { message: 'No saved state found' });
            return;
          }

          this.gateway.logger.info('STORAGE', { 
            message: 'Restoring system state...', 
            appsCount: state.apps?.length || 0 
          });

          this.gateway.logger.info('STORAGE', { message: 'System state restored' });
        } catch (error) {
          this.gateway.logger.error('STORAGE', { 
            action: 'restore_system_state_failed', 
            error: error.message 
          });
        }
      }

      startAutoSave() {
        // Auto-save toutes les 30 secondes
        this.autoSaveInterval = setInterval(() => {
          this.saveSystemState();
        }, 30000);

        this.gateway.logger.info('STORAGE', { message: 'Auto-save enabled (30s interval)' });
      }

      stopAutoSave() {
        if (this.autoSaveInterval) {
          clearInterval(this.autoSaveInterval);
          this.autoSaveInterval = null;
        }
      }

      getStats() {
        return {
          connected: this.connected,
          type: this.connected ? 'LDSS' : 'localStorage',
          autoSave: !!this.autoSaveInterval
        };
      }
    }

    // ═══════════════════════════════════════════════
    // IPC ROUTER
    // ═══════════════════════════════════════════════
    class IPCRouter {
      constructor(gateway) {
        this.gateway = gateway;
        this.listeners = new Map();
      }

      emit(event, payload) {
        this.gateway.logger.info('IPC', { event, payload });

        this.gateway.apps.forEach((app) => {
          if (app.source && app.state === 'ready') {
            app.source.postMessage({
              type: 'ipc:event',
              event,
              payload
            }, '*');
          }
        });
      }

      on(event, callback) {
        if (!this.listeners.has(event)) {
          this.listeners.set(event, []);
        }
        this.listeners.get(event).push(callback);
      }
    }

    // ═══════════════════════════════════════════════
    // OS GATEWAY (Main Orchestrator)
    // ═══════════════════════════════════════════════
    class OSGateway {
      constructor() {
        this.apps = new Map();
        this.nextPid = 1;
        this.bootTime = null;

        this.logger = new SystemLogger();
        this.cpuManager = new CPUManager(this);
        this.windowManager = new WindowManager(this);
        this.storage = new StorageManager(this);
        this.ipc = new IPCRouter(this);

        this.initMessageListener();
        this.windowManager.setupDragListeners();
      }

      initMessageListener() {
        window.addEventListener('message', (e) => {
          try {
            const { type, pid, data } = e.data;

            // Si pas de PID fourni, essayer de le trouver via e.source
            let actualPid = pid;

            if (!actualPid || actualPid === null) {
              // Chercher l'app par son iframe source
              for (const [appPid, app] of this.apps.entries()) {
                if (app.iframe && app.iframe.contentWindow === e.source) {
                  actualPid = appPid;
                  this.logger.info('IPC', { 
                    action: 'pid_resolved_from_source', 
                    resolvedPid: actualPid 
                  });
                  break;
                }
              }
            }

            this.routeMessage(type, actualPid, data, e.source);
          } catch (error) {
            this.logger.error('IPC', { 
              action: 'message_handling_failed', 
              error: error.message,
              stack: error.stack 
            });
          }
        });
      }

      routeMessage(type, pid, data, source) {
        this.logger.info('IPC', { 
          action: 'message_received', 
          type, 
          pid, 
          hasData: !!data,
          hasSource: !!source
        });

        const routes = {
          'app:ready': () => this.handleAppReady(pid, source),
          'app:close': () => this.closeApp(pid),
          'app:minimize': () => this.windowManager.minimize(pid),
          'app:maximize': () => this.windowManager.maximize(pid),
          'app:update': (data) => this.handleAppUpdate(pid, data),
          'storage:set': (data) => this.storage.set(data.key, data.value),
          'storage:get': (data) => this.storage.get(data.key),
          'ipc:emit': (data) => this.ipc.emit(data.event, data.payload),
          'system:info:request': () => this.getSystemInfo(),
          'process:list:request': () => this.getProcessList(),
          'process:kill': (data) => this.closeApp(data.targetPid),
          'cpu:execute': (data) => this.cpuManager.executeTask(data.task, data.params),
          'cpu:batch': (data) => this.cpuManager.executeBatch(data.tasks),
          'cpu:stats': () => this.cpuManager.getStats(),
          'settings:apply': (data) => this.applySettings(data)
        };

        const handler = routes[type];

        if (!handler) {
          this.logger.warn('IPC', { 
            action: 'unknown_message_type', 
            type, 
            availableTypes: Object.keys(routes) 
          });
          return;
        }

        try {
          const result = handler(data);

          if (source && result instanceof Promise) {
            result.then(res => {
              source.postMessage({
                type: `${type}:response`,
                success: true,
                data: res
              }, '*');
            }).catch(error => {
              source.postMessage({
                type: `${type}:response`,
                success: false,
                error: error.message
              }, '*');
            });
          } else if (source) {
            source.postMessage({
              type: `${type}:response`,
              success: true,
              data: result
            }, '*');
          }
        } catch (error) {
          this.logger.error('IPC', { type, error: error.message });

          if (source) {
            source.postMessage({
              type: `${type}:response`,
              success: false,
              error: error.message
            }, '*');
          }
        }
      }

      // ═══════════════════════════════════════════════
      // NOUVEAU: APPLIQUER LES SETTINGS AU SYSTÈME
      // ═══════════════════════════════════════════════
      applySettings(settings) {
        this.logger.info('SYSTEM', { action: 'applying_settings', settings });

        const desktop = document.getElementById('desktop');
        const wallpaper = document.getElementById('desktop-wallpaper');
        const usernameEl = document.getElementById('taskbar-username');

        // Appliquer le thème
        if (settings.theme) {
          desktop.className = 'active';
          desktop.classList.add(`theme-${settings.theme}`);
          this.logger.info('SYSTEM', { action: 'theme_applied', theme: settings.theme });
        }

        // Appliquer le fond d'écran
        if (settings.wallpaper) {
          wallpaper.style.backgroundImage = `url(${settings.wallpaper})`;
          this.logger.info('SYSTEM', { action: 'wallpaper_applied' });
        } else {
          wallpaper.style.backgroundImage = '';
        }

        // Afficher le nom d'utilisateur
        if (settings.username) {
          usernameEl.textContent = settings.username;
          this.logger.info('SYSTEM', { action: 'username_displayed', username: settings.username });
        }

        // Sauvegarder les settings
        this.storage.set('system_settings', settings);
      }

      // ═══════════════════════════════════════════════
      // NOUVEAU: CHARGER ET APPLIQUER LES SETTINGS AU BOOT
      // ═══════════════════════════════════════════════
      async loadAndApplySettings() {
        try {
          this.logger.info('SYSTEM', { message: 'Loading system settings...' });

          const settings = await this.storage.get('system_settings');

          if (settings) {
            this.logger.info('SYSTEM', { message: 'Settings found, applying...', settings });
            this.applySettings(settings);
          } else {
            this.logger.info('SYSTEM', { message: 'No settings found, using defaults' });
            
            // Appliquer les settings par défaut
            const defaultSettings = {
              theme: 'dark',
              username: 'Utilisateur',
              wallpaper: null
            };
            
            this.applySettings(defaultSettings);
          }
        } catch (error) {
          this.logger.error('SYSTEM', { 
            action: 'load_settings_failed', 
            error: error.message 
          });
        }
      }

      async launchApp(appName, options = {}) {
        const pid = this.nextPid++;

        this.logger.info('APP', { action: 'launch', appName, pid });

        try {
          const windowEl = this.windowManager.create({
            title: options.title || appName,
            width: options.width || 800,
            height: options.height || 600,
            pid
          });

          const iframe = document.createElement('iframe');
          iframe.src = `apps/${appName}/app.html`;
          iframe.style.width = '100%';
          iframe.style.height = '100%';
          iframe.style.border = 'none';

          windowEl.querySelector('.window-content').appendChild(iframe);

          this.apps.set(pid, {
            pid,
            name: appName,
            iframe,
            windowEl,
            state: 'launching',
            launchedAt: Date.now(),
            source: null
          });

          this.updateTaskbar();

          // Attendre que l'app soit ready (10s max)
          await this.waitForAppReady(pid, 10000);

          this.logger.info('APP', { action: 'launch_success', appName, pid });

          return pid;

        } catch (error) {
          this.logger.error('APP', { action: 'launch_failed', appName, pid, error: error.message });
          return pid;
        }
      }

      waitForAppReady(pid, timeout = 10000) {
        return new Promise((resolve, reject) => {
          let attempts = 0;
          const maxAttempts = timeout / 100;

          const checkReady = () => {
            const app = this.apps.get(pid);

            if (!app) {
              this.logger.error('APP', { action: 'wait_ready_failed', pid, reason: 'app not found' });
              reject(new Error(`App ${pid} not found`));
              return;
            }

            if (app.state === 'ready') {
              this.logger.info('APP', { action: 'wait_ready_success', pid, attempts });
              resolve();
              return;
            }

            attempts++;

            if (attempts >= maxAttempts) {
              this.logger.warn('APP', { 
                action: 'wait_ready_timeout', 
                pid, 
                attempts, 
                currentState: app.state,
                message: 'App did not send app:ready in time - continuing anyway'
              });
              resolve();
              return;
            }

            setTimeout(checkReady, 100);
          };

          checkReady();
        });
      }

      handleAppReady(pid, source) {
        this.logger.info('IPC', { 
          action: 'app_ready_received', 
          pid, 
          hasSource: !!source 
        });

        const app = this.apps.get(pid);

        if (!app) {
          this.logger.error('IPC', { 
            action: 'app_ready_failed', 
            pid, 
            reason: 'app not found in apps map' 
          });
          return;
        }

        app.state = 'ready';
        app.source = source;

        // Envoyer config à l'app
        if (source) {
          source.postMessage({
            type: 'kernel:config',
            data: {
              pid,
              appName: app.name,
              storage: { available: true },
              ipc: { available: true }
            }
          }, '*');

          this.logger.info('IPC', { 
            action: 'kernel_config_sent', 
            pid, 
            appName: app.name 
          });
        } else {
          this.logger.warn('IPC', { 
            action: 'no_source_for_response', 
            pid 
          });
        }
      }

      handleAppUpdate(pid, data) {
        this.logger.info('APP', { action: 'update', pid, data });
      }

      closeApp(pid) {
        const app = this.apps.get(pid);
        if (!app) return;

        this.logger.info('APP', { action: 'close', pid, name: app.name });

        this.windowManager.close(pid);

        if (app.iframe && app.iframe.parentNode) {
          app.iframe.parentNode.removeChild(app.iframe);
        }

        this.apps.delete(pid);
        this.updateTaskbar();
      }

      updateTaskbar() {
        const taskbarApps = document.getElementById('taskbar-apps');
        taskbarApps.innerHTML = '';

        this.apps.forEach((app) => {
          const btn = document.createElement('button');
          btn.className = 'taskbar-app';
          btn.textContent = app.name;
          btn.dataset.pid = app.pid;

          const win = this.windowManager.windows.get(app.pid);
          if (win && win.state !== 'minimized') {
            btn.classList.add('active');
          }

          btn.addEventListener('click', () => {
            if (win.state === 'minimized') {
              this.windowManager.restore(app.pid);
            } else {
              this.windowManager.focus(app.pid);
            }
          });

          taskbarApps.appendChild(btn);
        });
      }

      getSystemInfo() {
        return {
          uptime: Date.now() - this.bootTime,
          apps: {
            running: Array.from(this.apps.values()).filter(a => a.state === 'ready').length,
            total: this.apps.size
          },
          logs: this.logger.getStats(),
          storage: this.storage.getStats(),
          cpu: this.cpuManager.getStats()
        };
      }

      getProcessList() {
        return Array.from(this.apps.values()).map(app => ({
          pid: app.pid,
          name: app.name,
          state: app.state,
          launchedAt: app.launchedAt
        }));
      }

      async boot() {
        this.bootTime = Date.now();

        this.logger.info('SYSTEM', { message: 'Booting NEXUS OS...' });

        await this.storage.init();

        // ✅ NOUVEAU: Charger et appliquer les settings au boot
        await this.loadAndApplySettings();

        this.logger.info('SYSTEM', { message: 'NEXUS OS ready' });
      }
    }

    // ═══════════════════════════════════════════════
    // BOOT SEQUENCE
    // ═══════════════════════════════════════════════

    // ✅ FIX 1: AVAILABLE_APPS COMPLET (9 apps)
    const AVAILABLE_APPS = [
      { name: 'calculator', title: 'Calculatrice', desc: 'Calculatrice de base' },
      { name: 'terminal', title: 'Terminal', desc: 'Interface de ligne de commande' },
      { name: 'notepad', title: 'Bloc-notes', desc: 'Éditeur de texte' },
      { name: 'file-manager', title: 'Gestionnaire de fichiers', desc: 'Parcourir les fichiers' },
      { name: 'code-editor', title: 'Éditeur de code', desc: 'Éditeur avec coloration syntaxique' },
      { name: 'repl', title: 'JavaScript REPL', desc: 'Exécuter du code JavaScript' },
      { name: 'docs', title: 'Documentation', desc: 'Guide du système' },
      { name: 'task-manager', title: 'Gestionnaire de tâches', desc: 'Monitorer les processus' },
      { name: 'settings', title: 'Paramètres', desc: 'Configurer le système' }
    ];

    let gateway;

    async function bootSequence() {
      console.log('[BOOT] Boot sequence START');

      try {
        const powerBtn = document.getElementById('power-button');
        const bootLogs = document.getElementById('boot-logs');
        const bootScreen = document.getElementById('boot-screen');
        const desktop = document.getElementById('desktop');

        if (!powerBtn || !bootLogs || !bootScreen || !desktop) {
          throw new Error('Required DOM elements not found');
        }

        console.log('[BOOT] All DOM elements found');

        powerBtn.style.display = 'none';
        bootLogs.classList.add('visible');

        const logs = [
          '[BIOS] Initializing system...',
          '[BIOS] Memory check: OK',
          '[BIOS] Boot device: Browser',
          '[KERNEL] Loading NEXUS OS Gateway...',
          '[KERNEL] Initializing CPU Manager (4 cores)...',
          '[KERNEL] Initializing Window Manager...',
          '[KERNEL] Initializing Storage Manager...',
          '[KERNEL] Initializing IPC Router...',
          '[KERNEL] System modules loaded',
          '[INIT] Starting desktop environment...',
          '[INIT] Loading applications registry...',
          '[INIT] Applying system settings...',
          '[INIT] System ready'
        ];

        for (const log of logs) {
          await new Promise(resolve => setTimeout(resolve, 150));
          const logEl = document.createElement('div');
          logEl.className = 'boot-log';
          logEl.textContent = log;
          bootLogs.appendChild(logEl);
          bootLogs.scrollTop = bootLogs.scrollHeight;
          console.log('[BOOT]', log);
        }

        await new Promise(resolve => setTimeout(resolve, 500));

        console.log('[BOOT] Creating OS Gateway...');
        gateway = new OSGateway();

        console.log('[BOOT] Calling gateway.boot()...');
        await gateway.boot();

        console.log('[BOOT] Gateway booted successfully');

        bootScreen.classList.add('hidden');
        desktop.classList.add('active');

        console.log('[BOOT] Desktop shown, initializing desktop...');
        initDesktop();

        console.log('[BOOT] Boot sequence COMPLETE');

      } catch (error) {
        console.error('[BOOT] FATAL ERROR:', error);
        console.error('[BOOT] Stack:', error.stack);
        alert('Boot failed: ' + error.message + '\n\nCheck console for details');
        throw error;
      }
    }

    function initDesktop() {
      updateClock();
      setInterval(updateClock, 1000);

      const startButton = document.getElementById('start-button');
      const startMenu = document.getElementById('start-menu');

      startButton.addEventListener('click', (e) => {
        e.stopPropagation();
        startMenu.classList.toggle('visible');
      });

      document.addEventListener('click', (e) => {
        if (!startMenu.contains(e.target) && e.target !== startButton) {
          startMenu.classList.remove('visible');
        }
      });

      populateStartMenu();
    }

    function populateStartMenu() {
      const appsList = document.getElementById('start-apps-list');
      appsList.innerHTML = '';

      // ✅ FIX: Afficher seulement les 7 premières apps (sans task-manager et settings)
      AVAILABLE_APPS.slice(0, 7).forEach(app => {
        const btn = document.createElement('button');
        btn.className = 'start-app';
        btn.innerHTML = `
          <div class="start-app-name">${app.title}</div>
          <div class="start-app-desc">${app.desc}</div>
        `;

        btn.addEventListener('click', async () => {
          document.getElementById('start-menu').classList.remove('visible');
          try {
            await gateway.launchApp(app.name, { title: app.title });
          } catch (error) {
            console.error('[ERROR] Failed to launch app:', error);
          }
        });

        appsList.appendChild(btn);
      });

      // ✅ Les apps système (task-manager et settings) sont déjà dans le HTML
      const systemApps = document.querySelectorAll('#start-menu .start-app[data-app]');
      systemApps.forEach(btn => {
        btn.addEventListener('click', async () => {
          const appName = btn.dataset.app;
          document.getElementById('start-menu').classList.remove('visible');
          try {
            await gateway.launchApp(appName, { title: btn.querySelector('.start-app-name').textContent });
          } catch (error) {
            console.error('[ERROR] Failed to launch app:', error);
          }
        });
      });
    }

    function updateClock() {
      const now = new Date();
      const hours = String(now.getHours()).padStart(2, '0');
      const minutes = String(now.getMinutes()).padStart(2, '0');
      document.getElementById('system-time').textContent = `${hours}:${minutes}`;
    }

    // ═══════════════════════════════════════════════
    // POWER BUTTON
    // ═══════════════════════════════════════════════

    function initPowerButton() {
      const powerBtn = document.getElementById('power-button');

      if (!powerBtn) {
        console.error('[CRITICAL] Power button not found in DOM!');
        alert('CRITICAL ERROR: Power button not found');
        return;
      }

      console.log('[INIT] Power button found, attaching listener...');

      powerBtn.addEventListener('click', () => {
        console.log('[DEBUG] Power button clicked');
        console.log('[DEBUG] Starting boot sequence...');

        try {
          bootSequence().catch(error => {
            console.error('[DEBUG] Boot failed:', error);
            alert('Boot failed: ' + error.message);
          });
        } catch (error) {
          console.error('[DEBUG] Boot error (sync):', error);
          alert('Boot error: ' + error.message);
        }
      });

      console.log('[INIT] Power button listener attached successfully');
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initPowerButton);
    } else {
      initPowerButton();
    }

    // Register Service Worker
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .then((registration) => {
            console.log('[SW] Service Worker registered:', registration.scope);
          })
          .catch((error) => {
            console.error('[SW] Service Worker registration failed:', error);
          });
      });
    }

    console.log('[NEXUS OS] System loaded. Click Power On to boot.');
  </script>
</body>
</html>